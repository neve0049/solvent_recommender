import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import sys
import matplotlib.pyplot as plt
from io import BytesIO
import webbrowser
import base64
import PyPDF2
import os
import re

# Configuration des chemins des fichiers
EXCEL_PATH = "KDDB.xlsx"
DBDT_PATH = "DBDT.xlsx"
DBDQ_PATH = "DBDQ.xlsx"

# Configuration de l'application
st.set_page_config(
    page_title="Quaterco",
    page_icon="üß™",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Style CSS personnalis√©
st.markdown("""
    <style>
    .main {
        background-color: #f5f5f5;
    }
    .stButton>button {
        background-color: #4CAF50;
        color: white;
        height: 3em;
        width: 100%;
        border-radius: 5px;
        font-size: 16px;
    }
    .stFileUploader>div>div>button {
        background-color: #4CAF50;
        color: white;
    }
    .css-1aumxhk {
        background-color: #f0f2f6;
    }
    .sidebar .sidebar-content {
        background-color: #e8f5e9;
    }
    h1, h2, h3 {
        color: #2e7d32;
    }
    </style>
    """, unsafe_allow_html=True)

# =============================================
# Fonctions utilitaires
# =============================================

@st.cache_data
def load_excel_sheets(file_path):
    """Charge les noms de feuilles d'un fichier Excel avec gestion d'erreur"""
    try:
        return pd.ExcelFile(file_path).sheet_names
    except Exception as e:
        st.error(f"Erreur de chargement du fichier {file_path}: {str(e)}")
        return []

def create_phase_display(row, labels, is_quaternary=False):
    """Cr√©e l'affichage des compositions des phases"""
    if is_quaternary:
        return {
            "UP": {
                "vol1": row['%Vol1 - UP'],
                "vol2": row['%Vol2 - UP'],
                "vol3": row['%Vol3 - UP'],
                "vol4": row['%Vol4 - UP']
            },
            "LP": {
                "vol1": row['%Vol1 - LP'],
                "vol2": row['%Vol2 - LP'],
                "vol3": row['%Vol3 - LP'],
                "vol4": row['%Vol4 - LP']
            },
            "labels": labels
        }
    else:
        return {
            "UP": {
                "vol1": row['%Vol1 - UP'],
                "vol2": row['%Vol2 - UP'],
                "vol3": row['%Vol3 - UP']
            },
            "LP": {
                "vol1": row['%Vol1 - LP'],
                "vol2": row['%Vol2 - LP'],
                "vol3": row['%Vol3 - LP']
            },
            "labels": labels
        }

def quaternary_to_3d(v1, v2, v3, v4):
    """Convertit des coordonn√©es quaternaires (v1+v2+v3+v4=100) en coordonn√©es 3D"""
    # Normalisation des pourcentages (de 0-100 √† 0-1)
    total = v1 + v2 + v3 + v4
    v1_norm = v1 / total
    v2_norm = v2 / total
    v3_norm = v3 / total
    v4_norm = v4 / total
    
    # Configuration des axes
    x = v4_norm  # %Vol4 sur l'axe X
    y = v3_norm  # %Vol3 sur l'axe Y
    z = v2_norm  # %Vol2 sur l'axe Z
    
    return x, y, z

def get_file_download_link(file_data, filename, text):
    b64 = base64.b64encode(file_data).decode()
    href = f'<a href="data:file/txt;base64,{b64}" download="{filename}">{text}</a>'
    return href

# =============================================
# Pages de l'application
# =============================================

def show_home_page():
    st.title("Quaterco - Toolbox for data visualization of predictive methodologies")
    st.markdown("""
    Welcome to Quaterco! A toolbox allowing you to access a database of phase diagrams for biphasic solvent systems and the distribution coefficient KD of commmon compounds found in plants for those systems. You can also  upload your excel files from COSMOthermX and your list of HSP to visualize them.
    """)
    
    st.image("CPCDISKGCPC.png")
    
    st.markdown("""
    ### Main features :
    - **KD Database Explorer** : Explore a database containing 200+ common compounds and their distribution coefficient KD in different biphasic solvent systems
    - **Ternary Phase Diagrams** : Database of ternary phase diagrams
    - **Quaternary Phase Diagrams** : Database of quaternary phase diagrams
    - **Hansen Solubility Parameters** : Plot your HSP by uploading your excel file
    - **Ternary Plot Diagram** : Plot your ternary phase diagram by uploading your file or a file generated by COSMOthermX
    - **Quaternary Plot Diagram** : Plot your quaternary phase diagram by uploading your file or a file generated by COSMOthermX
    """)

# Modules KD Database
def show_kddb_page():
    """Page KD Database Explorer - Version avec s√©lection par ligne"""
    st.title("KD Database Explorer")
    
    # Chargement des noms de feuilles
    sheet_names = load_excel_sheets(EXCEL_PATH)
    if not sheet_names:
        return
        
    # Zone de recherche
    col1, col2 = st.columns([0.7, 0.3])
    with col1:
        search_query = st.text_input(
            "Enter a compound name",
            key="search_input",
            placeholder="Search"
        )
    with col2:
        st.write("")  # Pour l'alignement
        if st.button("Search", key="search_button"):
            st.session_state.search_triggered = True

    # Gestion de la recherche
    if 'search_triggered' not in st.session_state:
        st.session_state.search_triggered = False

    if st.session_state.search_triggered or search_query:
        search_value = search_query.strip().lower()
        matching_sheets = [sheet for sheet in sheet_names if search_value in sheet.lower()]
        
        if not matching_sheets:
            st.warning("Aucune correspondance trouv√©e.")
        else:
            # Affichage des r√©sultats
            selected_sheet = st.radio(
                "Feuilles correspondantes:",
                matching_sheets,
                key="sheet_selection"
            )
            
            # Chargement des donn√©es de la feuille s√©lectionn√©e
            try:
                df = pd.read_excel(EXCEL_PATH, sheet_name=selected_sheet)
                
                # Colonnes requises et optionnelles
                required_cols = ['Log KD', 'System', 'Composition']
                additional_cols = ['Log P (Pubchem)', 'Log P (COSMO-RS)']
                
                # V√©rification des colonnes disponibles
                available_cols = [col for col in required_cols + additional_cols if col in df.columns]
                
                if len([col for col in required_cols if col in available_cols]) < len(required_cols):
                    st.error("Les colonnes requises ne sont pas toutes pr√©sentes dans la feuille.")
                else:
                    # S√©lection interactive par ligne
                    st.subheader("S√©lectionnez une entr√©e")
                    
                    # Cr√©ation d'un dataframe pour la s√©lection
                    selection_df = df[available_cols].copy()
                    selection_df.insert(0, 'Select', False)
                    
                    # Configuration des colonnes pour st.data_editor
                    column_config = {
                        "Select": st.column_config.CheckboxColumn(
                            "Select",
                            help="Select a line by checking a box",
                            default=False,
                            required=True
                        ),
                        "Composition": st.column_config.TextColumn("Composition"),
                    }
                    
                    # Affichage du tableau avec case √† cocher
                    edited_df = st.data_editor(
                        selection_df,
                        column_config=column_config,
                        use_container_width=True,
                        hide_index=True,
                        disabled=[col for col in available_cols],
                        key="data_editor"
                    )
                    
                    # R√©cup√©ration de la ligne s√©lectionn√©e
                    selected_rows = edited_df[edited_df['Select']]
                    
                    if not selected_rows.empty:
                        # Ne garder que la premi√®re s√©lection si plusieurs cases coch√©es
                        selected_row = selected_rows.iloc[0]
                        system_name = selected_row['System']
                        selected_composition = str(selected_row['Composition'])  # Convertir en string pour la comparaison
                        
                        # D√©terminer si c'est un syst√®me ternaire ou quaternaire
                        is_quaternary = st.checkbox("Afficher en diagramme quaternaire", key="quaternary_check")
                        
                        # Chargement des donn√©es du syst√®me correspondant
                        try:
                            # Charger toutes les feuilles du fichier appropri√©
                            target_file = DBDQ_PATH if is_quaternary else DBDT_PATH
                            all_sheets = pd.read_excel(target_file, sheet_name=None)
                            
                            if system_name not in all_sheets:
                                st.error(f"Aucune donn√©e trouv√©e pour le syst√®me {system_name}")
                            else:
                                df_system = all_sheets[system_name]
                                # Convertir la colonne Composition en string pour la comparaison
                                df_system['Composition'] = df_system['Composition'].astype(str)
                                df_filtered = df_system[df_system['Composition'] == selected_composition]
                                
                                if df_filtered.empty:
                                    st.error(f"Aucune donn√©e trouv√©e pour la composition {selected_composition} dans le syst√®me {system_name}")
                                    st.write("Compositions disponibles:", df_system['Composition'].unique())
                                else:
                                    if is_quaternary:
                                        show_quaternary_diagram(df_system, df_filtered, system_name, selected_composition)
                                    else:
                                        show_ternary_diagram(df_system, df_filtered, system_name, selected_composition)
                        
                        except Exception as e:
                            st.error(f"Erreur lors du chargement du syst√®me {system_name}: {str(e)}")
                    else:
                        st.info("Veuillez s√©lectionner une ligne dans le tableau pour afficher les d√©tails")
            
            except Exception as e:
                st.error(f"Erreur lors du chargement des donn√©es: {str(e)}")

    # Bouton pour effacer la recherche
    if st.session_state.search_triggered:
        if st.button("Effacer la recherche"):
            st.session_state.search_triggered = False
            st.rerun()

def show_dbdt_page():
    """Page Ternary Phase Diagrams - Version compl√®te"""
    st.title("Ternary Phase Diagrams")
    
    try:
        # Chargement des noms de feuilles
        sheet_names = load_excel_sheets(DBDT_PATH)
        if not sheet_names:
            st.warning("Aucune feuille trouv√©e dans le fichier DBDT.xlsx")
            return
        
        # S√©lection de la feuille
        selected_sheet = st.selectbox(
            "S√©lectionnez un syst√®me",
            sheet_names,
            key="dbdt_sheet_select"
        )
        
        # Chargement des donn√©es
        try:
            df = pd.read_excel(DBDT_PATH, sheet_name=selected_sheet)
            
            # V√©rifier que les colonnes n√©cessaires existent
            required_cols = ['Composition', '%Vol1 - UP', '%Vol2 - UP', '%Vol3 - UP', 
                            '%Vol1 - LP', '%Vol2 - LP', '%Vol3 - LP']
            
            missing_cols = [col for col in required_cols if col not in df.columns]
            if missing_cols:
                st.error(f"Colonnes manquantes: {', '.join(missing_cols)}")
                return
            
            # Nettoyage des donn√©es
            df = df.dropna(subset=['%Vol1 - UP', '%Vol2 - UP', '%Vol3 - UP', 
                                 '%Vol1 - LP', '%Vol2 - LP', '%Vol3 - LP'])
            
            # R√©cup√©rer les noms des solvants (premi√®re ligne apr√®s l'en-t√™te)
            lib_row = pd.read_excel(DBDT_PATH, sheet_name=selected_sheet, header=None).iloc[1]
            labels = {
                'vol1': lib_row[0],
                'vol2': lib_row[1],
                'vol3': lib_row[2],
                'sheet': selected_sheet
            }
            
            # Cr√©ation du graphique
            fig = go.Figure()

            # Courbe UP
            fig.add_trace(go.Scatter(
                x=df['%Vol3 - UP'],
                y=df['%Vol2 - UP'],
                mode='lines+markers',
                name='UP',
                line=dict(color='black', width=2),
                marker=dict(color='red', size=8, symbol='circle'),
                customdata=df[['Composition', '%Vol1 - UP', '%Vol2 - UP', '%Vol3 - UP']].values,
                hovertemplate=(
                    f'<b>Composition</b>: %{{customdata[0]}}<br>'
                    f'Phase: UP<br>{labels["vol1"]}: %{{customdata[1]:.2f}}<br>'
                    f'{labels["vol2"]}: %{{customdata[2]:.2f}}<br>'
                    f'{labels["vol3"]}: %{{customdata[3]:.2f}}<extra></extra>'
                )
            ))

            # Courbe LP
            fig.add_trace(go.Scatter(
                x=df['%Vol3 - LP'],
                y=df['%Vol2 - LP'],
                mode='lines+markers',
                name='LP',
                line=dict(color='black', width=2),
                marker=dict(color='blue', size=8, symbol='circle'),
                customdata=df[['Composition', '%Vol1 - LP', '%Vol2 - LP', '%Vol3 - LP']].values,
                hovertemplate=(
                    f'<b>Composition</b>: %{{customdata[0]}}<br>'
                    f'Phase: LP<br>{labels["vol1"]}: %{{customdata[1]:.2f}}<br>'
                    f'{labels["vol2"]}: %{{customdata[2]:.2f}}<br>'
                    f'{labels["vol3"]}: %{{customdata[3]:.2f}}<extra></extra>'
                )
            ))

            # Lignes de connexion
            for _, row in df.iterrows():
                fig.add_trace(go.Scatter(
                    x=[row['%Vol3 - UP'], row['%Vol3 - LP']],
                    y=[row['%Vol2 - UP'], row['%Vol2 - LP']],
                    mode='lines',
                    line=dict(color='blue', width=2),
                    showlegend=False,
                    hoverinfo='none'
                ))

            # Triangle de r√©f√©rence
            fig.add_trace(go.Scatter(
                x=[0, 1], y=[1, 0],
                mode='lines',
                line=dict(color='black', dash='dash'),
                name='x + y = 1',
                hoverinfo='none'
            ))

            # Configuration des axes
            fig.update_layout(
                xaxis=dict(
                    title=f'% {labels["vol3"]} (%Vol3)',
                    range=[0, 1],
                    dtick=0.1,
                    showgrid=True,
                    gridwidth=1.5,
                    gridcolor='#666666'
                ),
                yaxis=dict(
                    title=f'% {labels["vol2"]} (%Vol2)',
                    range=[0, 1],
                    dtick=0.1,
                    showgrid=True,
                    gridwidth=1.5,
                    gridcolor='#666666'
                ),
                title=f"Ternary Phase Diagram: {labels['vol1']} / {labels['vol2']} / {labels['vol3']}",
                width=1400,
                height=700,
                hovermode='closest'
            )

            # Affichage en deux colonnes
            col1, col2 = st.columns([0.8, 0.2])

            with col1:
                st.plotly_chart(fig, use_container_width=True)

                # Affichage des donn√©es brutes
                st.subheader("Raw Data")
                st.dataframe(
                    df,
                    use_container_width=True,
                    hide_index=True,
                    height=400
                )

            with col2:
                # S√©lection interactive
                st.subheader("Select a composition")
                selected_composition = st.selectbox(
                    "Select by composition", 
                    df['Composition'].unique(),
                    key="dbdt_composition_select"
                )
                
                selected_row = df[df['Composition'] == selected_composition].iloc[0]
                phase_data = create_phase_display(selected_row, labels)
                
                # Affichage des compositions
                st.subheader("Phase composition")
                
                for phase, color in [('UP', 'red'), ('LP', 'blue')]:
                    with st.expander(f"Phase {phase}", expanded=True):
                        st.markdown(f"""
                        **{labels['vol1']}:** {phase_data[phase]['vol1']:.2f}  
                        **{labels['vol2']}:** {phase_data[phase]['vol2']:.2f}  
                        **{labels['vol3']}:** {phase_data[phase]['vol3']:.2f}
                        """)

        except Exception as e:
            st.error(f"Erreur lors du chargement des donn√©es: {str(e)}")
            st.error("Veuillez v√©rifier que le fichier DBDT.xlsx est correctement format√©.")

    except Exception as e:
        st.error(f"Erreur critique: {str(e)}")

def show_ternary_diagram(df_system, df_filtered, system_name, selected_composition):
    """Affiche un diagramme ternaire"""
    # R√©cup√©rer les labels des solvants depuis la premi√®re ligne
    lib_row = pd.read_excel(DBDT_PATH, sheet_name=system_name, header=None).iloc[1]
    labels = {
        'vol1': lib_row[0],
        'vol2': lib_row[1],
        'vol3': lib_row[2],
        'sheet': system_name
    }
    
    # V√©rifier que les colonnes n√©cessaires existent
    required_cols = [f'%Vol1 - UP', f'%Vol2 - UP', f'%Vol3 - UP',
                    f'%Vol1 - LP', f'%Vol2 - LP', f'%Vol3 - LP']
    
    for col in required_cols:
        if col not in df_system.columns:
            st.error(f"Colonne manquante: {col}")
            return
    
    # Cr√©ation du graphique ternaire
    fig = go.Figure()
    
    # Traces pour les phases UP et LP
    for phase, color in [('UP', 'red'), ('LP', 'blue')]:
        fig.add_trace(go.Scatter(
            x=df_system[f'%Vol3 - {phase}'],
            y=df_system[f'%Vol2 - {phase}'],
            mode='markers',
            name=f'Phase {phase}',
            marker=dict(color=color, size=10, line=dict(width=1, color='DarkSlateGrey')),
            customdata=np.stack((
                df_system['Composition'].astype(str),
                df_system[f'%Vol1 - {phase}'],
                df_system[f'%Vol2 - {phase}'],
                df_system[f'%Vol3 - {phase}']
            ), axis=-1),
            hovertemplate=(
                "<b>Composition</b>: %{customdata[0]}<br>"
                "<b>%Vol1</b>: %{customdata[1]:.2f}<br>"
                "<b>%Vol2</b>: %{customdata[2]:.2f}<br>"
                "<b>%Vol3</b>: %{customdata[3]:.2f}<extra></extra>"
            )
        ))
    
    # Lignes de connexion
    for _, row in df_system.iterrows():
        fig.add_trace(go.Scatter(
            x=[row['%Vol3 - UP'], row['%Vol3 - LP']],
            y=[row['%Vol2 - UP'], row['%Vol2 - LP']],
            mode='lines',
            line=dict(color='gray', width=1, dash='dot'),
            showlegend=False,
            hoverinfo='none'
        ))
    
    # Ligne x + y = 1
    x_vals = np.linspace(0, 1, 100)
    fig.add_trace(go.Scatter(
        x=x_vals,
        y=1 - x_vals,
        mode='lines',
        name='x + y = 1',
        line=dict(color='green', width=2),
        hoverinfo='none'
    ))
    
    # Points s√©lectionn√©s
    for phase in ['UP', 'LP']:
        fig.add_trace(go.Scatter(
            x=[df_filtered[f'%Vol3 - {phase}'].values[0]],
            y=[df_filtered[f'%Vol2 - {phase}'].values[0]],
            mode='markers',
            name=f'S√©lection {phase}',
            marker=dict(
                color='black',
                size=16,
                symbol='circle-open',
                line=dict(width=2)
            ),
            hoverinfo='none'
        ))
    
    # Mise en forme du graphique
    fig.update_layout(
        title=dict(
            text=f"Diagramme de Phase Ternaire - Syst√®me {system_name}",
            x=0.5,
            font=dict(size=16)
        ),
        xaxis=dict(
            title='%Vol3',
            range=[0, 1],
            constrain='domain'
        ),
        yaxis=dict(
            title='%Vol2',
            range=[0, 1],
            scaleanchor='x',
            scaleratio=1
        ),
        showlegend=True,
        legend=dict(
            orientation='h',
            yanchor='bottom',
            y=1.02,
            xanchor='right',
            x=1
        ),
        margin=dict(l=60, r=60, t=80, b=60, pad=20),
        height=600
    )
    
    # Affichage en deux colonnes (graphique + compositions)
    col1, col2 = st.columns([0.7, 0.3])
    
    with col1:
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        st.subheader("Compositions des phases")
        
        phase_data = create_phase_display(df_filtered.iloc[0], labels)
        
        for phase, color in [('UP', 'red'), ('LP', 'blue')]:
            with st.expander(f"Phase {phase}", expanded=True):
                st.markdown(f"""
                **{labels['vol1']}:** {phase_data[phase]['vol1']:.2f}  
                **{labels['vol2']}:** {phase_data[phase]['vol2']:.2f}  
                **{labels['vol3']}:** {phase_data[phase]['vol3']:.2f}
                """)

def show_quaternary_diagram(df_system, df_filtered, system_name, selected_composition):
    """Affiche un diagramme quaternaire"""
    lib_row = pd.read_excel(DBDQ_PATH, sheet_name=system_name, header=None).iloc[1]
    labels = {
        'vol1': lib_row[0],
        'vol2': lib_row[1],
        'vol3': lib_row[2],
        'vol4': lib_row[3],
        'sheet': system_name
    }
    
    # Conversion des coordonn√©es
    def convert_row(row, phase):
        v1 = row[f'%Vol1 - {phase}']
        v2 = row[f'%Vol2 - {phase}']
        v3 = row[f'%Vol3 - {phase}']
        v4 = row[f'%Vol4 - {phase}']
        return quaternary_to_3d(v1, v2, v3, v4)
    
    # Appliquer la conversion
    df_system[['x_up', 'y_up', 'z_up']] = df_system.apply(lambda x: convert_row(x, 'UP'), axis=1, result_type='expand')
    df_system[['x_lp', 'y_lp', 'z_lp']] = df_system.apply(lambda x: convert_row(x, 'LP'), axis=1, result_type='expand')
    df_filtered[['x_up', 'y_up', 'z_up']] = df_filtered.apply(lambda x: convert_row(x, 'UP'), axis=1, result_type='expand')
    df_filtered[['x_lp', 'y_lp', 'z_lp']] = df_filtered.apply(lambda x: convert_row(x, 'LP'), axis=1, result_type='expand')
    
    # Cr√©ation de la figure 3D
    fig = go.Figure()
    
    # Ajout des points UP (rouge)
    fig.add_trace(go.Scatter3d(
        x=df_system['x_up'],
        y=df_system['y_up'],
        z=df_system['z_up'],
        mode='markers',
        name='UP',
        marker=dict(color='red', size=5),
        customdata=df_system[['Composition', '%Vol1 - UP', '%Vol2 - UP', '%Vol3 - UP', '%Vol4 - UP']].values,
        hovertemplate=(
            f"<b>Phase UP</b><br>"
            f"<b>Composition</b>: %{{customdata[0]}}<br>"
            f"{labels['vol1']}: %{{customdata[1]:.2f}}%<br>"
            f"{labels['vol2']}: %{{customdata[2]:.2f}}%<br>"
            f"{labels['vol3']}: %{{customdata[3]:.2f}}%<br>"
            f"{labels['vol4']}: %{{customdata[4]:.2f}}%<extra></extra>"
        )
    ))
    
    # Ajout des points LP (bleu)
    fig.add_trace(go.Scatter3d(
        x=df_system['x_lp'],
        y=df_system['y_lp'],
        z=df_system['z_lp'],
        mode='markers',
        name='LP',
        marker=dict(color='blue', size=5),
        customdata=df_system[['Composition', '%Vol1 - LP', '%Vol2 - LP', '%Vol3 - LP', '%Vol4 - LP']].values,
        hovertemplate=(
            f"<b>Phase LP</b><br>"
            f"<b>Composition</b>: %{{customdata[0]}}<br>"
            f"{labels['vol1']}: %{{customdata[1]:.2f}}%<br>"
            f"{labels['vol2']}: %{{customdata[2]:.2f}}%<br>"
            f"{labels['vol3']}: %{{customdata[3]:.2f}}%<br>"
            f"{labels['vol4']}: %{{customdata[4]:.2f}}%<extra></extra>"
        )
    ))
    
    # Ajout des lignes de connexion
    for _, row in df_system.iterrows():
        fig.add_trace(go.Scatter3d(
            x=[row['x_up'], row['x_lp']],
            y=[row['y_up'], row['y_lp']],
            z=[row['z_up'], row['z_lp']],
            mode='lines',
            line=dict(color='gray', width=1),
            showlegend=False,
            hoverinfo='none'
        ))
    
    # Points s√©lectionn√©s
    for phase, color in [('UP', 'red'), ('LP', 'blue')]:
        fig.add_trace(go.Scatter3d(
            x=[df_filtered[f'x_{phase.lower()}'].values[0]],
            y=[df_filtered[f'y_{phase.lower()}'].values[0]],
            z=[df_filtered[f'z_{phase.lower()}'].values[0]],
            mode='markers',
            name=f'S√©lection {phase}',
            marker=dict(
                color='black',
                size=10,
                symbol='circle-open',
                line=dict(width=2)
            ),
            hoverinfo='none'
        ))
    
    # Configuration du layout avec les nouveaux axes
    fig.update_layout(
        scene=dict(
            xaxis=dict(title=f"% {labels['vol4']} (X)"),
            yaxis=dict(title=f"% {labels['vol3']} (Y)"),
            zaxis=dict(title=f"% {labels['vol2']} (Z)"),
            aspectmode='cube',
            camera=dict(
                up=dict(x=0, y=0, z=1),
                center=dict(x=0, y=0, z=0),
                eye=dict(x=1.25, y=1.25, z=1.25)
            )
        ),
        title=f"Quaternary Phase Diagram: {labels['vol1']} / {labels['vol2']} / {labels['vol3']} / {labels['vol4']}",
        width=1200,
        height=800,
        hovermode='closest'
    )
    
    # Affichage en deux colonnes (graphique + compositions)
    col1, col2 = st.columns([0.7, 0.3])
    
    with col1:
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        st.subheader("Compositions des phases")
        
        phase_data = create_phase_display(df_filtered.iloc[0], labels, is_quaternary=True)
        
        for phase, color in [('UP', 'red'), ('LP', 'blue')]:
            with st.expander(f"Phase {phase}", expanded=True):
                st.markdown(f"""
                **{labels['vol1']}:** {phase_data[phase]['vol1']:.2f}%  
                **{labels['vol2']}:** {phase_data[phase]['vol2']:.2f}%  
                **{labels['vol3']}:** {phase_data[phase]['vol3']:.2f}%  
                **{labels['vol4']}:** {phase_data[phase]['vol4']:.2f}%
                """)

def show_dbdq_page():
    """Page Quaternary Phase Diagrams"""
    st.title("Quaternary Phase Diagrams")
    
    # Chargement des noms de feuilles
    sheet_names = load_excel_sheets(DBDQ_PATH)
    if not sheet_names:
        return
    
    # Gestion des arguments pass√©s
    initial_sheet = None
    selected_composition = None
    if len(sys.argv) > 2:
        initial_sheet = sys.argv[1]
        selected_composition = sys.argv[2]
    
    # S√©lection de la feuille
    selected_sheet = st.selectbox(
        "S√©lectionnez un syst√®me",
        sheet_names,
        index=sheet_names.index(initial_sheet) if initial_sheet in sheet_names else 0
    )
    
    # Chargement des donn√©es
    try:
        df = pd.read_excel(DBDQ_PATH, sheet_name=selected_sheet)
        lib_row = pd.read_excel(DBDQ_PATH, sheet_name=selected_sheet, header=None).iloc[1]
        labels = {
            'vol1': lib_row[0],
            'vol2': lib_row[1],
            'vol3': lib_row[2],
            'vol4': lib_row[3],
            'sheet': selected_sheet
        }
        
        # Nettoyage des donn√©es
        required_cols = ['%Vol1 - UP', '%Vol2 - UP', '%Vol3 - UP', '%Vol4 - UP',
                        '%Vol1 - LP', '%Vol2 - LP', '%Vol3 - LP', '%Vol4 - LP']
        df = df.dropna(subset=required_cols)
        
        # Conversion des coordonn√©es
        def convert_row(row, phase):
            v1 = row[f'%Vol1 - {phase}']
            v2 = row[f'%Vol2 - {phase}']
            v3 = row[f'%Vol3 - {phase}']
            v4 = row[f'%Vol4 - {phase}']
            return quaternary_to_3d(v1, v2, v3, v4)
        
        # Appliquer la conversion
        df[['x_up', 'y_up', 'z_up']] = df.apply(lambda x: convert_row(x, 'UP'), axis=1, result_type='expand')
        df[['x_lp', 'y_lp', 'z_lp']] = df.apply(lambda x: convert_row(x, 'LP'), axis=1, result_type='expand')
        
        # Cr√©ation de la figure 3D
        fig = go.Figure()
        
        # Ajout des points UP (rouge)
        fig.add_trace(go.Scatter3d(
            x=df['x_up'],
            y=df['y_up'],
            z=df['z_up'],
            mode='markers',
            name='UP',
            marker=dict(color='red', size=5),
            customdata=df[['Composition', '%Vol1 - UP', '%Vol2 - UP', '%Vol3 - UP', '%Vol4 - UP']].values,
            hovertemplate=(
                f"<b>Phase UP</b><br>"
                f"<b>Composition</b>: %{{customdata[0]}}<br>"
                f"{labels['vol1']}: %{{customdata[1]:.2f}}%<br>"
                f"{labels['vol2']}: %{{customdata[2]:.2f}}%<br>"
                f"{labels['vol3']}: %{{customdata[3]:.2f}}%<br>"
                f"{labels['vol4']}: %{{customdata[4]:.2f}}%<extra></extra>"
            )
        ))
        
        # Ajout des points LP (bleu)
        fig.add_trace(go.Scatter3d(
            x=df['x_lp'],
            y=df['y_lp'],
            z=df['z_lp'],
            mode='markers',
            name='LP',
            marker=dict(color='blue', size=5),
            customdata=df[['Composition', '%Vol1 - LP', '%Vol2 - LP', '%Vol3 - LP', '%Vol4 - LP']].values,
            hovertemplate=(
                f"<b>Phase LP</b><br>"
                f"<b>Composition</b>: %{{customdata[0]}}<br>"
                f"{labels['vol1']}: %{{customdata[1]:.2f}}%<br>"
                f"{labels['vol2']}: %{{customdata[2]:.2f}}%<br>"
                f"{labels['vol3']}: %{{customdata[3]:.2f}}%<br>"
                f"{labels['vol4']}: %{{customdata[4]:.2f}}%<extra></extra>"
            )
        ))
        
        # Ajout des lignes de connexion
        for _, row in df.iterrows():
            fig.add_trace(go.Scatter3d(
                x=[row['x_up'], row['x_lp']],
                y=[row['y_up'], row['y_lp']],
                z=[row['z_up'], row['z_lp']],
                mode='lines',
                line=dict(color='gray', width=1),
                showlegend=False,
                hoverinfo='none'
            ))
        
        # Configuration du layout avec les nouveaux axes
        fig.update_layout(
            scene=dict(
                xaxis=dict(title=f"% {labels['vol4']} (X)"),
                yaxis=dict(title=f"% {labels['vol3']} (Y)"),
                zaxis=dict(title=f"% {labels['vol2']} (Z)"),
                aspectmode='cube',
                camera=dict(
                    up=dict(x=0, y=0, z=1),
                    center=dict(x=0, y=0, z=0),
                    eye=dict(x=1.25, y=1.25, z=1.25)
                )
            ),
            title=f"Quaternary Phase Diagram: {labels['vol1']} / {labels['vol2']} / {labels['vol3']} / {labels['vol4']}",
            width=1200,
            height=800,
            hovermode='closest',
            margin=dict(l=60, r=60, t=80, b=60)
        )

        # Affichage en deux colonnes
        col1, col2 = st.columns([0.7, 0.3])

        with col1:
            st.plotly_chart(fig, use_container_width=True)

            # Affichage des donn√©es brutes
            st.subheader("Raw Data")
            with st.expander("View complete dataset", expanded=False):
                st.dataframe(
                    df,
                    use_container_width=True,
                    hide_index=True,
                    height=400,
                    column_config={
                        "Composition": st.column_config.TextColumn("Composition"),
                        "%Vol1 - UP": st.column_config.NumberColumn("UP Vol1", format="%.2f"),
                        "%Vol2 - UP": st.column_config.NumberColumn("UP Vol2", format="%.2f"),
                        "%Vol3 - UP": st.column_config.NumberColumn("UP Vol3", format="%.2f"),
                        "%Vol4 - UP": st.column_config.NumberColumn("UP Vol4", format="%.2f"),
                        "%Vol1 - LP": st.column_config.NumberColumn("LP Vol1", format="%.2f"),
                        "%Vol2 - LP": st.column_config.NumberColumn("LP Vol2", format="%.2f"),
                        "%Vol3 - LP": st.column_config.NumberColumn("LP Vol3", format="%.2f"),
                        "%Vol4 - LP": st.column_config.NumberColumn("LP Vol4", format="%.2f")
                    }
                )

        with col2:
            # S√©lection interactive
            st.subheader("Select a point")
            selected_composition = st.selectbox(
                "Select by composition", 
                df['Composition'].unique(),
                index=list(df['Composition']).index(selected_composition) if selected_composition in df['Composition'].values else 0
            )
            
            selected_row = df[df['Composition'] == selected_composition].iloc[0]
            phase_data = create_phase_display(selected_row, labels, is_quaternary=True)
            
            # Affichage des compositions
            st.subheader("Phase Compositions")
            
            for phase, color in [('UP', 'red'), ('LP', 'blue')]:
                with st.expander(f"Phase {phase}", expanded=True):
                    st.markdown(f"""
                    **{labels['vol1']}:** {phase_data[phase]['vol1']:.2f}%  
                    **{labels['vol2']}:** {phase_data[phase]['vol2']:.2f}%  
                    **{labels['vol3']}:** {phase_data[phase]['vol3']:.2f}%  
                    **{labels['vol4']}:** {phase_data[phase]['vol4']:.2f}%
                    """)

            # Bouton pour explorer dans KD Database
            if st.button("Find in KD Database"):
                # V√©rifier si le syst√®me existe dans KDDB
                try:
                    kddb_sheets = load_excel_sheets(EXCEL_PATH)
                    system_name = selected_sheet
                    
                    if system_name in kddb_sheets:
                        st.session_state.current_page = "kddb"
                        st.session_state.search_query = system_name
                        st.session_state.search_triggered = True
                        st.rerun()
                    else:
                        st.warning(f"No matching system found in KD Database for {system_name}")
                except Exception as e:
                    st.error(f"Error accessing KD Database: {str(e)}")

    except Exception as e:
        st.error(f"Error processing data: {str(e)}")

# Module Hansen Solubility Parameters
def show_hansen_page():
    st.header("üß™ Hansen Solubility Parameters")
    
    with st.expander("‚ÑπÔ∏è Instructions"):
        st.write("""
        Upload the excel file containing your data. The file must contain the following columns:
        Œ¥D, Œ¥P, Œ¥H, Compounds, Type (by default the color are 0 = Red = petro-sourced or unsafe compound, 1 = Green = bio-sourced compound, 2 = Blue = simulated HSP from COSMOQuick or other prediction software), CAS, R0.
        """)
    
    uploaded_file = st.file_uploader("Upload your Excel file containing your data", type=["xlsx"])
    
    if uploaded_file is not None:
        try:
            data = pd.read_excel(uploaded_file)
            required_columns = ['Œ¥D', 'Œ¥P', 'Œ¥H', 'Type', 'Compounds', 'CAS', 'R0']
            
            if not all(col in data.columns for col in required_columns):
                st.error(f"Colonnes requises manquantes: {', '.join(required_columns)}")
            else:
                # Pr√©paration des donn√©es
                x = data['Œ¥D'].astype(float)
                y = data['Œ¥P'].astype(float)
                z = data['Œ¥H'].astype(float)
                names = data['Compounds']
                types = data['Type']
                CAS = data['CAS']
                radii = data['R0'].astype(float)
                
                # Couleurs et l√©gendes
                colors = ['red', 'green', 'blue']
                type_labels = ['Non-Green', 'Green', 'Simulated']
                
                # Bouton ON/OFF pour les noms des compos√©s
                show_names = st.toggle("Display compound names", value=False)
                
                # Cr√©ation du graphique 3D
                fig = go.Figure()
                
                # Ajout des points avec des couleurs selon le type
                for i in range(len(x)):
                    fig.add_trace(go.Scatter3d(
                        x=[x[i]], y=[y[i]], z=[z[i]],
                        mode='markers' + ('+text' if show_names else ''),
                        marker=dict(
                            size=6,
                            color=colors[types[i]],
                            opacity=0.8
                        ),
                        text=names[i] if show_names else None,
                        textposition="top center",
                        name=names[i],
                        hoverinfo='text',
                        hovertext=f"""
                        <b>{names[i]}</b><br>
                        CAS: {CAS[i]}<br>
                        Œ¥D: {x[i]:.2f}<br>
                        Œ¥P: {y[i]:.2f}<br>
                        Œ¥H: {z[i]:.2f}<br>
                        R0: {radii[i]:.2f}
                        """,
                        showlegend=False
                    ))
                
                # Mise en forme du graphique
                fig.update_layout(
                    scene=dict(
                        xaxis_title='Œ¥D',
                        yaxis_title='Œ¥P',
                        zaxis_title='Œ¥H',
                        xaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                        yaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                        zaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                    ),
                    margin=dict(l=0, r=0, b=0, t=30),
                    height=700,
                    legend=dict(
                        orientation="h",
                        yanchor="bottom",
                        y=1.02,
                        xanchor="right",
                        x=1
                    )
                )
                
                # Ajout de la l√©gende
                for i, label in enumerate(type_labels):
                    fig.add_trace(go.Scatter3d(
                        x=[None], y=[None], z=[None],
                        mode='markers',
                        marker=dict(size=10, color=colors[i]),
                        name=label,
                        showlegend=True
                    ))
                
                # Affichage du graphique
                st.plotly_chart(fig, use_container_width=True)
                
                # Section d'analyse interactive
                st.subheader("üîç Interactive Analysis")
                col1, col2 = st.columns(2)
                
                with col1:
                    # Recherche de compos√©
                    compound_name = st.selectbox(
                        "Search compound", 
                        [""] + sorted(names.unique()),
                        index=0
                    )
                    
                    if compound_name:
                        idx = names[names == compound_name].index[0]
                        st.success(f"Selected compound: {compound_name}")
                        
                        # Affichage des informations
                        st.write(f"**CAS:** {CAS[idx]}")
                        st.write(f"**Coordinates:** Œ¥D={x[idx]:.2f}, Œ¥P={y[idx]:.2f}, Œ¥H={z[idx]:.2f}")
                        st.write(f"**Hansen Sphere Radius (R0):** {radii[idx]:.2f}")
                        
                        # Bouton pour ouvrir dans PubChem
                        if st.button(f"üîé Search {compound_name} on PubChem"):
                            url = f"https://pubchem.ncbi.nlm.nih.gov/#query={CAS[idx]}"
                            webbrowser.open_new_tab(url)
                
                with col2:
                    # Visualisation de la sph√®re d'interaction
                    show_sphere = st.checkbox("Display Hansen Sphere")
                    
                    if show_sphere and compound_name:
                        idx = names[names == compound_name].index[0]
                        center = [x[idx], y[idx], z[idx]]
                        radius = radii[idx]
                        
                        # Cr√©ation de la sph√®re
                        u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
                        sphere_x = center[0] + radius * np.cos(u) * np.sin(v)
                        sphere_y = center[1] + radius * np.sin(u) * np.sin(v)
                        sphere_z = center[2] + radius * np.cos(v)
                        
                        # Ajout de la sph√®re au graphique
                        fig.add_trace(go.Surface(
                            x=sphere_x,
                            y=sphere_y,
                            z=sphere_z,
                            colorscale=[[0, 'rgba(255, 255, 0, 0.1)'], [1, 'rgba(255, 255, 0, 0.1)']],
                            showscale=False,
                            name=f"Hansen Sphere: {compound_name}"
                        ))
                        
                        st.plotly_chart(fig, use_container_width=True)
                
                # Options d'export
                st.subheader("üì§ Export data")
                export_format = st.radio("Export format", ["PNG", "HTML", "CSV"])
                
                if st.button("Export the results"):
                    if export_format == "PNG":
                        img_bytes = fig.to_image(format="png")
                        st.download_button(
                            label="Download PNG",
                            data=img_bytes,
                            file_name="hansen_parameters.png",
                            mime="image/png"
                        )
                    elif export_format == "HTML":
                        html = fig.to_html()
                        st.download_button(
                            label="Download HTML",
                            data=html,
                            file_name="hansen_parameters.html",
                            mime="text/html"
                        )
                    elif export_format == "CSV":
                        csv = data.to_csv(index=False)
                        st.download_button(
                            label="Download CSV",
                            data=csv,
                            file_name="hansen_data.csv",
                            mime="text/csv"
                        )
        
        except Exception as e:
            st.error(f"Error processing file: {str(e)}")

# Module Ternary Plot Diagram
def show_ternary_plot_page():
    st.header("üìê Ternary Plot Diagram")

    with st.expander("‚ÑπÔ∏è Instructions"):
        st.write("""
        1. Choose your data source type (Volume data or COSMO-RS data)
        2. Upload the corresponding file
        3. The ternary diagram will be generated automatically
        4. Use the tools to explore the visualization
        """)
    
    # Ajout du choix du type de donn√©es
    data_source = st.radio(
        "Select data source type",
        ["Import Volume data", "Import COSMO-RS data"],
        index=0,
        horizontal=True
    )
    
    if data_source == "Import Volume data":
        uploaded_file = st.file_uploader("Upload your Excel file with volume data", type=["xlsx"])
        
        if uploaded_file is not None:
            try:
                data = pd.read_excel(uploaded_file)
                required_columns = ['V1', 'V2', "V1'", "V2'"]
                
                if not all(col in data.columns for col in required_columns):
                    st.error(f"Missing columns: {', '.join(required_columns)}")
                else:
                    # Le reste du code existant pour Volume data...
                    v1 = data['V1']
                    v2 = data['V2']
                    v1_prime = data["V1'"]
                    v2_prime = data["V2'"]
                    
                    # Cr√©ation de la figure matplotlib
                    fig, ax = plt.subplots(figsize=(8, 8))
                    
                    # Dessin du triangle rectangle
                    ax.plot([0, 1, 0, 0], [0, 0, 1, 0], 'k-', linewidth=2)
                    
                    # Ajout des lignes et points
                    for i in range(len(v1)):
                        color = np.random.rand(3,)
                        ax.plot([v1[i], v1_prime[i]], [v2[i], v2_prime[i]], 
                                color=color, marker='o', markersize=6, linewidth=2)
                    
                    # Configuration des axes
                    ax.set_xlim(0, 1)
                    ax.set_ylim(0, 1)
                    ax.set_aspect('equal', 'box')
                    
                    # Labels des axes
                    ax.set_xlabel(data.iloc[0, 7] if len(data.columns) > 7 else 'Solvent 1', fontsize=12)
                    ax.set_ylabel(data.iloc[0, 8] if len(data.columns) > 8 else 'Solvent 2', fontsize=12)
                    
                    # Ajout de la grille
                    ax.grid(True, linestyle='--', alpha=0.5)
                    ax.set_xticks(np.arange(0, 1.1, 0.1))
                    ax.set_yticks(np.arange(0, 1.1, 0.1))
                    
                    # Titre
                    title = f"{data.iloc[0, 7] if len(data.columns) > 7 else 'Solvent 1'} / {data.iloc[0, 8] if len(data.columns) > 8 else 'Solvent 2'} / {data.iloc[0, 9] if len(data.columns) > 9 else 'Solvent 3'}"
                    ax.set_title(title, fontsize=14, pad=20)
                    
                    # Affichage dans Streamlit
                    st.pyplot(fig)
                    
            except Exception as e:
                 st.error(f"Error processing file: {str(e)}")
    
    elif data_source == "Import COSMO-RS data":
        uploaded_file = st.file_uploader("Upload your COSMO-RS Excel file", type=["xls", "xlsx"])
        
        if uploaded_file is not None:
            try:
                # Lire le fichier COSMO-RS
                df = pd.read_excel(uploaded_file, header=None)
                
                # Extraire les m√©tadonn√©es depuis la cellule A1
                a1_content = str(df.iloc[0, 0])
                
                # Fonction pour extraire les compos√©s
                def extract_compounds(a1_content):
                    compounds_match = re.search(r"compounds job \d+ :(.+?)(;|$)(?=\s*\w+ job \d+ :|$)", 
                                            a1_content, re.IGNORECASE | re.DOTALL)
                    if not compounds_match:
                        raise ValueError("Compounds section not found in A1")
                    
                    compounds_section = compounds_match.group(1)
                    compounds = re.findall(r"([^;(]+)\s*\((\d+)\)", compounds_section)
                    
                    if len(compounds) < 3:
                        raise ValueError(f"Only {len(compounds)} compounds found (3 expected)")
                    
                    compounds_sorted = sorted(compounds, key=lambda x: int(x[1]))
                    return [c[0].strip().replace(" ", "_").lower() for c in compounds_sorted[:3]]
                
                # Fonction pour extraire les masses mol√©culaires
                def extract_molecular_weights(a1_content):
                    mw_match = re.search(r"molecular weights ([0-9.]+)\s*\(1\)\s*([0-9.]+)\s*\(2\)\s*([0-9.]+)\s*\(3\)", 
                                        a1_content, re.IGNORECASE)
                    if not mw_match:
                        raise ValueError("Molecular weights not found in A1")
                    return [float(mw_match.group(1)), float(mw_match.group(2)), float(mw_match.group(3))]
                
                # Extraire les compos√©s et masses mol√©culaires
                COMPOUNDS = extract_compounds(a1_content)
                MOLECULAR_WEIGHTS = extract_molecular_weights(a1_content)
                
                st.success(f"Detected compounds: {COMPOUNDS}")
                st.success(f"Molecular weights: {MOLECULAR_WEIGHTS}")
                
                # Saisie des densit√©s
                st.subheader("üî¢ Enter densities (g/mL)")
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    p1 = st.number_input(f"Density of {COMPOUNDS[0]}", min_value=0.1, max_value=2.0, value=1.0, step=0.01)
                with col2:
                    p2 = st.number_input(f"Density of {COMPOUNDS[1]}", min_value=0.1, max_value=2.0, value=1.0, step=0.01)
                with col3:
                    p3 = st.number_input(f"Density of {COMPOUNDS[2]}", min_value=0.1, max_value=2.0, value=1.0, step=0.01)
                
                if st.button("Calculate volumes"):
                    # Charger les donn√©es (en sautant les en-t√™tes)
                    data_df = pd.read_excel(uploaded_file, header=39)
                    
                    # V√©rifier les colonnes n√©cessaires
                    PHASE1_COLS = ["x`(1)", "x`(2)", "x`(3)"]
                    PHASE2_COLS = ["x``(1)", "x``(2)", "x``(3)"]
                    
                    if not all(col in data_df.columns for col in PHASE1_COLS + PHASE2_COLS):
                        st.error("Required columns not found in the file")
                    else:
                        # Calculer les valeurs
                        results = pd.DataFrame()
                        densities = [p1, p2, p3]
                        
                        # Fonction pour calculer les valeurs
                        def calculate_values(df, results, x_cols, mw, densities, phase_suffix=""):
                            for i in range(3):
                                x_col = x_cols[i]
                                x = pd.to_numeric(df[x_col], errors='coerce')
                                results[f"x{i+1}{phase_suffix}"] = x
                                results[f"g{i+1}{phase_suffix}"] = x * mw[i]
                                results[f"V{i+1}{phase_suffix}"] = results[f"g{i+1}{phase_suffix}"] / densities[i]
                                mask = (x == 0)
                                results.loc[mask, f"g{i+1}{phase_suffix}"] = 0
                                results.loc[mask, f"V{i+1}{phase_suffix}"] = 0
                            return results
                        
                        # Calcul pour les deux phases
                        results = calculate_values(data_df, results, PHASE1_COLS, MOLECULAR_WEIGHTS, densities)
                        results = calculate_values(data_df, results, PHASE2_COLS, MOLECULAR_WEIGHTS, densities, "'")
                        
                        # Normalisation
                        def normalize_phase(df, cols):
                            sum_values = df[cols].sum(axis=1)
                            for col in cols:
                                mask = (sum_values > 0)
                                df.loc[mask, col] = df.loc[mask, col] / sum_values[mask]
                            return df
                        
                        v_cols_phase1 = [f"V{i+1}" for i in range(3)]
                        v_cols_phase2 = [f"V{i+1}'" for i in range(3)]
                        
                        results = normalize_phase(results, v_cols_phase1)
                        results = normalize_phase(results, v_cols_phase2)
                        
                        # Afficher les r√©sultats
                        st.subheader("üìä Calculated Volume Data")
                        st.dataframe(results)
                        
                        # T√©l√©chargement des r√©sultats
                        csv = results.to_csv(index=False)
                        st.download_button(
                            label="Download calculated data as CSV",
                            data=csv,
                            file_name="ternary_cosmo_rs_volume_data.csv",
                            mime="text/csv"
                        )
                        
                        # Cr√©ation du diagramme ternaire
                        fig, ax = plt.subplots(figsize=(8, 8))
                        
                        # Dessin du triangle rectangle
                        ax.plot([0, 1, 0, 0], [0, 0, 1, 0], 'k-', linewidth=2)
                        
                        # Ajout des lignes et points
                        for i in range(len(results)):
                            color = np.random.rand(3,)
                            ax.plot(
                                [results.iloc[i]['V1'], results.iloc[i]["V1'"]],
                                [results.iloc[i]['V2'], results.iloc[i]["V2'"]],
                                color=color, marker='o', markersize=6, linewidth=2
                            )
                        
                        # Configuration des axes
                        ax.set_xlim(0, 1)
                        ax.set_ylim(0, 1)
                        ax.set_aspect('equal', 'box')
                        
                        # Labels des axes
                        ax.set_xlabel(COMPOUNDS[0], fontsize=12)
                        ax.set_ylabel(COMPOUNDS[1], fontsize=12)
                        
                        # Ajout de la grille
                        ax.grid(True, linestyle='--', alpha=0.5)
                        ax.set_xticks(np.arange(0, 1.1, 0.1))
                        ax.set_yticks(np.arange(0, 1.1, 0.1))
                        
                        # Titre
                        title = f"{COMPOUNDS[0]} / {COMPOUNDS[1]} / {COMPOUNDS[2]}"
                        ax.set_title(title, fontsize=14, pad=20)
                        
                        # Affichage dans Streamlit
                        st.pyplot(fig)
            
            except Exception as e:
                st.error(f"Error processing COSMO-RS file: {str(e)}")
    
    # Options d'export (commun aux deux types de donn√©es)
    if uploaded_file is not None and ((data_source == "Import Volume data" and 'fig' in locals()) or 
                                    (data_source == "Import COSMO-RS data" and 'fig' in locals() and st.session_state.get('calculated', False))):
        st.subheader("üì§ Export Options")
        export_format = st.selectbox("Export format", ["PNG", "PDF", "SVG"])
        
        if st.button("Export the diagram"):
            buf = BytesIO()
            if export_format == "PNG":
                fig.savefig(buf, format="png", dpi=300)
                st.download_button(
                    label="Download PNG",
                    data=buf.getvalue(),
                    file_name="ternary_diagram.png",
                    mime="image/png"
                )
            elif export_format == "PDF":
                fig.savefig(buf, format="pdf")
                st.download_button(
                    label="Download PDF",
                    data=buf.getvalue(),
                    file_name="ternary_diagram.pdf",
                    mime="application/pdf"
                )
            elif export_format == "SVG":
                fig.savefig(buf, format="svg")
                st.download_button(
                    label="Download SVG",
                    data=buf.getvalue(),
                    file_name="ternary_diagram.svg",
                    mime="image/svg+xml"
                )

# Module Quaternary Plot Diagram
def show_quaternary_plot_page():
    st.header("üßä Quaternary Phase Diagram")
    
    with st.expander("‚ÑπÔ∏è Instructions"):
        st.write("""
        1. Choose your data source type (Volume data or COSMO-RS data)
        2. Upload the corresponding file
        3. The quaternary 3D diagram will be generated automatically
        4. Use the tools to explore the visualization
        """)
    
    # Ajout du choix du type de donn√©es
    data_source = st.radio(
        "Select data source type",
        ["Import Volume data", "Import COSMO-RS data"],
        index=0,
        horizontal=True
    )
    
    if data_source == "Import Volume data":
        uploaded_file = st.file_uploader("Upload your Excel file with volume data", type=["xlsx"])
        
        if uploaded_file is not None:
            try:
                data = pd.read_excel(uploaded_file)
                required_columns = ['V1', 'V2', 'V3', "V1'", "V2'", "V3'"]
                
                if not all(col in data.columns for col in required_columns):
                    st.error(f"Missing required columns: {', '.join(required_columns)}")
                else:
                    # Le reste du code existant pour Volume data...
                    # Pr√©paration des donn√©es
                    x = data['V1']
                    y = data['V2']
                    z = data['V3']
                    w = 1 - x - y - z
                    x_prime = data["V1'"]
                    y_prime = data["V2'"]
                    z_prime = data["V3'"]
                    w_prime = 1 - x_prime - y_prime - z_prime
                    
                    # Cr√©ation du graphique 3D
                    fig = go.Figure()
                    
                    # Ajout des lignes
                    for i in range(len(x)):
                        color = f'rgb({np.random.randint(50,200)},{np.random.randint(50,200)},{np.random.randint(50,200)})'
                        fig.add_trace(go.Scatter3d(
                            x=[x[i], x_prime[i]],
                            y=[y[i], y_prime[i]],
                            z=[z[i], z_prime[i]],
                            mode='lines+markers',
                            line=dict(width=4, color=color),
                            marker=dict(size=5, color=color),
                            name=f"Line {i+1}",
                            hovertemplate=(
                    f"Point 1: (V1={x[i]:.2f}, V2={y[i]:.2f}, V3={z[i]:.2f}, V4={w[i]:.2f})<br>"
                    f"Point 2: (V1'={x_prime[i]:.2f}, V2'={y_prime[i]:.2f}, V3'={z_prime[i]:.2f}, V4'={w_prime[i]:.2f})"
                )
                        ))
                    
                    # Ajout de la pyramide
                    pyramid_vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])
                    pyramid_edges = [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]
                    
                    for edge in pyramid_edges:
                        fig.add_trace(go.Scatter3d(
                            x=[pyramid_vertices[edge[0]][0], pyramid_vertices[edge[1]][0]],
                            y=[pyramid_vertices[edge[0]][1], pyramid_vertices[edge[1]][1]],
                            z=[pyramid_vertices[edge[0]][2], pyramid_vertices[edge[1]][2]],
                            mode='lines',
                            line=dict(color='black', width=3),
                            showlegend=False,
                            hoverinfo='none'
                        ))
                    
                    # Mise en forme
                    fig.update_layout(
                        scene=dict(
                            xaxis_title=data.iloc[0, 9] if len(data.columns) > 9 else 'V1',
                            yaxis_title=data.iloc[0, 10] if len(data.columns) > 10 else 'V2',
                            zaxis_title=data.iloc[0, 11] if len(data.columns) > 11 else 'V3',
                            xaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                            yaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                            zaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                        ),
                        margin=dict(l=0, r=0, b=0, t=30),
                        height=700,
                        title={
                            'text': f"{data.iloc[0, 9] if len(data.columns) > 9 else 'V1'} / {data.iloc[0, 10] if len(data.columns) > 10 else 'V2'} / {data.iloc[0, 11] if len(data.columns) > 11 else 'V3'} / {data.iloc[0, 12] if len(data.columns) > 12 else 'V4'}",
                            'x': 0.5,
                            'font': {'size': 16}
                        }
                    )
                    
                    # Affichage du graphique
                    st.plotly_chart(fig, use_container_width=True)
                    
            except Exception as e:
                st.error(f"Error processing file: {str(e)}")
    
    elif data_source == "Import COSMO-RS data":
        uploaded_file = st.file_uploader("Upload your COSMO-RS Excel file", type=["xls", "xlsx"])
        
        if uploaded_file is not None:
            try:
                # Lire le fichier COSMO-RS
                df = pd.read_excel(uploaded_file, sheet_name=0, header=None)
                
                # Extraire les noms des compos√©s
                col1_name = df.iloc[5, 1]  # Contenu cellule B6
                col2_name = df.iloc[4, 1]   # Contenu cellule B5
                col3_name = df.iloc[3, 1]   # Contenu cellule B4
                col4_name = df.iloc[2, 1]   # Contenu cellule B3
                
                # Recharger les donn√©es en sautant les en-t√™tes initiaux
                data_df = pd.read_excel(uploaded_file, sheet_name=0, header=5)
                
                # Cr√©er un nouveau dataframe avec les colonnes demand√©es
                result_df = pd.DataFrame()
                
                # Remplir les colonnes selon les num√©ros dans la colonne A (Nr)
                result_df[col1_name] = data_df.loc[data_df.iloc[:, 0] == 4].iloc[:, 3].reset_index(drop=True)
                result_df[col2_name] = data_df.loc[data_df.iloc[:, 0] == 3].iloc[:, 3].reset_index(drop=True)
                result_df[col3_name] = data_df.loc[data_df.iloc[:, 0] == 2].iloc[:, 3].reset_index(drop=True)
                result_df[col4_name] = data_df.loc[data_df.iloc[:, 0] == 1].iloc[:, 3].reset_index(drop=True)
                
                # Ajouter la colonne Total
                result_df['Total'] = result_df.sum(axis=1)
                
                # Demander les densit√©s
                st.subheader("üî¢ Enter densities (g/mL)")
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    p1 = st.number_input(f"Density of {col1_name}", min_value=0.1, max_value=2.0, value=1.0, step=0.01)
                with col2:
                    p2 = st.number_input(f"Density of {col2_name}", min_value=0.1, max_value=2.0, value=1.0, step=0.01)
                with col3:
                    p3 = st.number_input(f"Density of {col3_name}", min_value=0.1, max_value=2.0, value=1.0, step=0.01)
                with col4:
                    p4 = st.number_input(f"Density of {col4_name}", min_value=0.1, max_value=2.0, value=1.0, step=0.01)
                
                if st.button("Calculate volumes"):
                    # Calculer les volumes V1-V4
                    result_df['V1'] = result_df[col1_name] / p1
                    result_df['V2'] = result_df[col2_name] / p2
                    result_df['V3'] = result_df[col3_name] / p3
                    result_df['V4'] = result_df[col4_name] / p4
                    
                    # Ajouter les colonnes W'
                    result_df["W1'"] = data_df.loc[data_df.iloc[:, 0] == 4].iloc[:, 6].reset_index(drop=True)
                    result_df["W2'"] = data_df.loc[data_df.iloc[:, 0] == 3].iloc[:, 6].reset_index(drop=True)
                    result_df["W3'"] = data_df.loc[data_df.iloc[:, 0] == 2].iloc[:, 6].reset_index(drop=True)
                    result_df["W4'"] = data_df.loc[data_df.iloc[:, 0] == 1].iloc[:, 6].reset_index(drop=True)
                    
                    # Calculer les volumes V'
                    result_df["V1'"] = result_df["W1'"] / p1
                    result_df["V2'"] = result_df["W2'"] / p2
                    result_df["V3'"] = result_df["W3'"] / p3
                    result_df["V4'"] = result_df["W4'"] / p4
                    
                    # Normaliser les volumes pour qu'ils somment √† 1
                    total_v = result_df[['V1', 'V2', 'V3', 'V4']].sum(axis=1)
                    result_df['V1'] = result_df['V1'] / total_v
                    result_df['V2'] = result_df['V2'] / total_v
                    result_df['V3'] = result_df['V3'] / total_v
                    result_df['V4'] = result_df['V4'] / total_v
                    
                    total_v_prime = result_df[["V1'", "V2'", "V3'", "V4'"]].sum(axis=1)
                    result_df["V1'"] = result_df["V1'"] / total_v_prime
                    result_df["V2'"] = result_df["V2'"] / total_v_prime
                    result_df["V3'"] = result_df["V3'"] / total_v_prime
                    result_df["V4'"] = result_df["V4'"] / total_v_prime
                    
                    # Afficher les donn√©es calcul√©es
                    st.subheader("üìä Calculated Volume Data")
                    st.dataframe(result_df)
                    
                    # T√©l√©chargement des r√©sultats
                    csv = result_df.to_csv(index=False)
                    st.download_button(
                        label="Download calculated data as CSV",
                        data=csv,
                        file_name="cosmo_rs_volume_data.csv",
                        mime="text/csv"
                    )
                    
                    # Pr√©paration des donn√©es pour le graphique
                    x = result_df['V1']
                    y = result_df['V2']
                    z = result_df['V3']
                    w = 1 - x - y - z
                    x_prime = result_df["V1'"]
                    y_prime = result_df["V2'"]
                    z_prime = result_df["V3'"]
                    w_prime = 1 - x_prime - y_prime - z_prime
                    
                    # Cr√©ation du graphique 3D
                    fig = go.Figure()
                    
                    # Ajout des lignes
                    for i in range(len(x)):
                        color = f'rgb({np.random.randint(50,200)},{np.random.randint(50,200)},{np.random.randint(50,200)})'
                        fig.add_trace(go.Scatter3d(
                            x=[x[i], x_prime[i]],
                            y=[y[i], y_prime[i]],
                            z=[z[i], z_prime[i]],
                            mode='lines+markers',
                            line=dict(width=4, color=color),
                            marker=dict(size=5, color=color),
                            name=f"Line {i+1}",
                            hovertemplate=(
                    f"Point 1: (V1={x[i]:.2f}, V2={y[i]:.2f}, V3={z[i]:.2f}, V4={w[i]:.2f})<br>"
                    f"Point 2: (V1'={x_prime[i]:.2f}, V2'={y_prime[i]:.2f}, V3'={z_prime[i]:.2f}, V4'={w_prime[i]:.2f})"
                )
                        ))
                    
                    # Ajout de la pyramide
                    pyramid_vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])
                    pyramid_edges = [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]
                    
                    for edge in pyramid_edges:
                        fig.add_trace(go.Scatter3d(
                            x=[pyramid_vertices[edge[0]][0], pyramid_vertices[edge[1]][0]],
                            y=[pyramid_vertices[edge[0]][1], pyramid_vertices[edge[1]][1]],
                            z=[pyramid_vertices[edge[0]][2], pyramid_vertices[edge[1]][2]],
                            mode='lines',
                            line=dict(color='black', width=3),
                            showlegend=False,
                            hoverinfo='none'
                        ))
                    
                    # Mise en forme
                    fig.update_layout(
                        scene=dict(
                            xaxis_title=col1_name,
                            yaxis_title=col2_name,
                            zaxis_title=col3_name,
                            xaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                            yaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                            zaxis=dict(gridcolor='lightgray', backgroundcolor='rgba(0,0,0,0)'),
                        ),
                        margin=dict(l=0, r=0, b=0, t=30),
                        height=700,
                        title={
                            'text': f"{col1_name} / {col2_name} / {col3_name} / {col4_name}",
                            'x': 0.5,
                            'font': {'size': 16}
                        }
                    )
                    
                    # Affichage du graphique
                    st.plotly_chart(fig, use_container_width=True)
                    
            except Exception as e:
                st.error(f"Error processing COSMO-RS file: {str(e)}")
    
    # Options avanc√©es (commun aux deux types de donn√©es)
    if uploaded_file is not None and ((data_source == "Import Volume data" and 'fig' in locals()) or 
                                    (data_source == "Import COSMO-RS data" and 'fig' in locals() and st.session_state.get('calculated', False))):
        st.subheader("üéö 3D Controls")
        col1, col2 = st.columns(2)
        
        with col1:
            # Animation de rotation
            if st.button("üîÑ Start rotation animation"):
                fig.update_layout(
                    scene=dict(
                        camera=dict(
                            up=dict(x=0, y=0, z=1),
                            center=dict(x=0, y=0, z=0),
                            eye=dict(x=1.25, y=1.25, z=1.25)
                        )
                    ),
                    updatemenus=[dict(
                        type="buttons",
                        buttons=[dict(
                            label="‚ñ∂Ô∏è",
                            method="animate",
                            args=[None, {"frame": {"duration": 50, "redraw": True}}]
                        )]
                    )])
                
                frames = []
                for angle in range(0, 360, 5):
                    frames.append(go.Frame(
                        layout=dict(
                            scene_camera=dict(
                                eye=dict(
                                    x=1.25 * np.cos(np.radians(angle)),
                                    y=1.25 * np.sin(np.radians(angle)),
                                    z=1.25
                                )
                            )
                        )
                    ))
                
                fig.frames = frames
                st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Export des donn√©es
            st.write("**Export diagram:**")
            export_format = st.radio("Format", ["HTML", "PNG"], key="quat_export", horizontal=True)
            
            if st.button("Generate export", key="quat_export_btn"):
                if export_format == "HTML":
                    html = fig.to_html()
                    st.download_button(
                        label="Download HTML",
                        data=html,
                        file_name="quaternary_diagram.html",
                        mime="text/html"
                    )
                elif export_format == "PNG":
                    img_bytes = fig.to_image(format="png")
                    st.download_button(
                        label="Download PNG",
                        data=img_bytes,
                        file_name="quaternary_diagram.png",
                        mime="image/png"
                    )

# =============================================
# Application principale
# =============================================

def main():
    # Initialisation de l'√©tat
    if 'current_page' not in st.session_state:
        st.session_state.current_page = "home"
    
    # Navigation
    with st.sidebar:
        st.title("Navigation")
        if st.button("üè† Home"):
            st.session_state.current_page = "home"
        if st.button("üîç KD Database Explorer"):
            st.session_state.current_page = "kddb"
        if st.button("üìä Ternary Phase Diagrams"):
            st.session_state.current_page = "dbdt"
        if st.button("üßä Quaternary Phase Diagrams"):
            st.session_state.current_page = "dbdq"
        if st.button("üß™ Hansen Solubility Parameters"):
            st.session_state.current_page = "hansen"
        if st.button("üìê Ternary Plot Diagram"):
            st.session_state.current_page = "ternary_plot"
        if st.button("üßä Quaternary Plot Diagram"):
            st.session_state.current_page = "quaternary_plot"
    
    # Router vers la page active
    try:
        if st.session_state.current_page == "home":
            show_home_page()
        elif st.session_state.current_page == "kddb":
            show_kddb_page()
        elif st.session_state.current_page == "dbdt":
            show_dbdt_page()
        elif st.session_state.current_page == "dbdq":
            show_dbdq_page()
        elif st.session_state.current_page == "hansen":
            show_hansen_page()
        elif st.session_state.current_page == "ternary_plot":
            show_ternary_plot_page()
        elif st.session_state.current_page == "quaternary_plot":
            show_quaternary_plot_page()
    except Exception as e:
        st.error(f"Une erreur est survenue: {str(e)}")
        st.session_state.current_page = "home"
        st.rerun()

if __name__ == "__main__":
    main()
